<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>

    <style>
        body {
            margin: 0;
            box-sizing: border-box;
            background-color: #3f3f3f;
            font-family: 'Lato', sans-serif;
        }

        .button {
            cursor: pointer;
            font: inherit;
            border: none;
            background-color: #4d1601;
            color: white;
            padding: 0.75rem 3rem;
            align-items: center;
            border-radius: 25px;
            font-weight: bold;
            margin: 2rem;
        }

        .button:hover,
        .button:active {
            background-color: #2c0d00;
        }

        .container {
            position: fixed;
            display: flex;
            flex-flow: column wrap;
            width: 100%;
            height: 100%;
            align-items: center;
            align-content: space-around;
            position:fixed;
        }

        .animation-container, .value-container {
            display: flex;
            flex-flow: column wrap;
            background-color: white;
            border-radius: 15px;
            padding: 2rem;
            align-items: center;
            justify-content: space-between;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.25);
        }

        .header {
            position: fixed;
            top: 0;
            left: 0;
            height: 5rem;
            width: 80%;
            background-color: #8a2b06;
            color: white;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 10%;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.25);
            z-index: 10;
        }

        .middle {
            position: fixed;
            display: flex;
            justify-content: space-around;
            flex-flow: row wrap;
            align-items: center;
            top: 100px;
            width: 100%;
        }

        .chart-container {
            max-width: 1500px;
            max-height: 1500px;
            min-width: 900px;
            min-height: 470px;
            background-color: white;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.25);
            border-radius: 14px;
            margin: 3rem;
            padding: 20px;
        }

        .val {
            padding: 0.2rem;
        }

        #input-container {
            display: flex;
            justify-content: space-around;
            flex-flow: row wrap;

        }

        .single-section {
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.25);
            border-radius: 14px;
            padding: 20px;
            margin: 1rem 3rem;
            background-color: white;
            display: flex;
            flex-direction: row;
        }

        .single-section label {
            display: flex;
            flex-direction: column;
        }

        .slider {
            -webkit-appearance: none;
            width: 100%;
            height: 5px 10px;
            margin: 5px;
            border-radius: 5px;
            background: #d3d3d3;
            outline: none;
            opacity: 0.7;
            -webkit-transition: .2s;
            transition: opacity .2s;
        }

        /* Mouse-over effects */
        .slider:hover {
            opacity: 1;
            /* Fully shown on mouse-over */
        }

        /* The slider handle (use -webkit- (Chrome, Opera, Safari, Edge) and -moz- (Firefox) to override default look) */
        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            /* Override default look */
            appearance: none;
            border-radius: 25px;
            width: 25px;
            /* Set a specific slider handle width */
            height: 25px;
            /* Slider handle height */
            background: #8a2b06;
            /* Green background */
            cursor: pointer;
            /* Cursor on hover */
        }

        .slider::-moz-range-thumb {
            width: 25px;
            /* Set a specific slider handle width */
            height: 25px;
            /* Slider handle height */
            background: #04AA6D;
            /* Green background */
            cursor: pointer;
            /* Cursor on hover */
        }
    </style>

    

    <div class="container">

        <header class="header">
            <h1>Wykresy funkcji</h1>
            <button class="button" onclick={onAtractorSelectClickHandler(0)}>Henon</button>
            <button class="button" onclick={onAtractorSelectClickHandler(1)}>Lozi</button>
            <button class="button" onclick={onAtractorSelectClickHandler(2)}>Duffing</button>
            <button class="button" onclick={onAtractorSelectClickHandler(3)}>GingerBreadMan</button>
            <button class="button" onclick={onAtractorSelectClickHandler(4)}>Ikeda</button>
        </header>

        <section class="middle">
            <div class="chart-container">
                <canvas id="myChart"></canvas>
            </div>

            <div class="value-container">
                <b>x</b>
                <span class="val">0</span>
                <b>y</b>
                <span class="val">0</span>
                <b>a</b>
                <span class="val">0</span>
                <b>b</b>
                <span class="val">0</span>
                <b>u</b>
                <span class="val">0</span>
            </div>

            <div class="animation-container">
                <h2><b>Animacja</b></h2>
                <span>Skok x</span><input value="0" type="number">
                <span>Skok y</span><input value="0" type="number">
                <span>Skok a</span><input value="0" type="number">
                <span>Skok b</span><input value="0" type="number">
                <span>Skok u</span><input value="0" type="number">
                <button class="button" onclick={onAnimationClickHandler()}>Start</button>
            </div>
            
               
            <div id="input-container"> 
        </section>
    </div>
    

   

    

    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>


    <script>
        const labelTemplate = ({ variable }, data) =>
            `<label>
        ${variable}:
        <input data-variable="${variable}" value=${data.value} data-type="val" type="number" onchange="updateInputInfo(this)"> 
        <input
          data-variable="${variable}" 
          class="slider" 
          data-type="range" 
          type="range"
          value=${data.value}
          min=${data.min}
          max=${data.max}
          step=${data.step}
          onchange="updateInputInfo(this)"
        />
        Min: <input data-variable="${variable}" value=${data.min} data-type="min" type="number" onchange="updateInputInfo(this)"> 
        Max: <input data-variable="${variable}" value=${data.max} data-type="max" type="number" onchange="updateInputInfo(this)">
        Step:
        <input data-variable="${variable}"  data-type="step" type="number"
        min="0"
        max="10"
        value=${data.step}
        onchange="updateInputInfo(this)" />
      </label>`;

        const currentSlidersParams = {};
        const slidersConfig = [
            { variable: 'x' },
            { variable: 'y' },
            { variable: 'a' },
            { variable: 'b' },
            { variable: 'u' },
        ];

        let selectedAtractor = 0;
        let intervalRefreshId = 0;
        let a = 1.2;
        let b = 0.3;
        let u = 0.9;
        let jumpRange = [
             0,
             0,
             0,
             0,
             0,
        ]

        const data_points = [{
            x: 0.1,
            y: 0.1
        }];

        const henon = (start, range) => {
            if (start == 0) return 0;
            if (start >= range) return 0;
            data_points[start] = {
                x: 1 + data_points[start - 1].y - a * data_points[start - 1].x * data_points[start - 1].x,
                y: b * data_points[start - 1].x
            }
            henon(start + 1, range)
        }

        const lozi = (start, range) => {
            if (start == 0) return 0;
            if (start >= range) return 0;
            data_points[start] = {
                x: 1 + data_points[start - 1].y - a * Math.abs(data_points[start - 1].x),
                y: b * data_points[start - 1].x
            }
            lozi(start + 1, range)
        }

        const duffing = (start, range) => {
            if (start == 0) return 0;
            if (start >= range) return 0;
            data_points[start] = {
                x: data_points[start - 1].y,
                y: -b * data_points[start - 1].x + a * data_points[start - 1].y - data_points[start - 1].y * data_points[start - 1].y * data_points[start - 1].y
            }
            duffing(start + 1, range)
        }

        const gingerBreadMan = (start, range) => {
            if (start == 0) return 0;
            if (start >= range) return 0;
            data_points[start] = {
                x: 1 - data_points[start - 1].y + Math.abs(data_points[start - 1].x),
                y: data_points[start - 1].x
            }
            gingerBreadMan(start + 1, range)
        }

        const ikeda = (start, range) => {
            if (start == 0) return 0;
            if (start >= range) return 0;

            data_points[start] = {
                x: 1 + u * (data_points[start - 1].x * Math.cos(t_points[start - 1]) - data_points[start - 1].y * Math.sin(t_points[start - 1])),
                y: u * (data_points[start - 1].x * Math.sin(t_points[start - 1]) + data_points[start - 1].y * Math.cos(t_points[start - 1]))
            }
            t_points[start] = 0.4 - 6 / (1 + data_points[start].x * data_points[start].x + data_points[start].y * data_points[start].y)
            ikeda(start + 1, range)
        }

        const onAtractorSelectClickHandler = (atractorNum) => {
            data_points[0].x = programDatabase[atractorNum].startingPoints.x.value;
            data_points[0].y = programDatabase[atractorNum].startingPoints.y.value;
            a = programDatabase[atractorNum].startingPoints.a.value;
            b = programDatabase[atractorNum].startingPoints.b.value;
            u = programDatabase[atractorNum].startingPoints.u.value;
            selectedAtractor = atractorNum;
            data["datasets"][0]["label"] = programDatabase[atractorNum].name;

            programDatabase[atractorNum].atractor(1, 5000);
            myChart.update();

            displayActaualParamsOnScreen(
                {
                    x: data_points[0].x,
                    y: data_points[0].y,
                    a,
                    b,
                    u
                }
            )

            slidersConfig.forEach( (config, index) => {
               
                const inputs = labels[index].querySelectorAll('input');  
                              
                inputs[0].value = programDatabase[atractorNum].startingPoints[config.variable].value;
                inputs[1].min = programDatabase[atractorNum].startingPoints[config.variable].min;
                inputs[1].max = programDatabase[atractorNum].startingPoints[config.variable].max;
                inputs[1].value = programDatabase[atractorNum].startingPoints[config.variable].step;
                inputs[2].value = programDatabase[atractorNum].startingPoints[config.variable].min;
                inputs[3].value = programDatabase[atractorNum].startingPoints[config.variable].max;
                inputs[4].value = programDatabase[atractorNum].startingPoints[config.variable].step;
                
               
            })
        }
        
        const onAnimationClickHandler = () => {
            if (!intervalRefreshId) {
                const animationInputs = document.querySelectorAll('.animation-container input');
                
                document.querySelectorAll('button')[5].innerHTML = 'Stop';
                
                animationInputs.forEach((input, index) => {
                    console.log(jumpRange[index]);
                    jumpRange[index] = input.value;
                })
                intervalCalblack(intervalCall);
                
            } else {
                clearInterval(intervalRefreshId);
                document.querySelectorAll('button')[5].innerHTML = 'Start';
                intervalRefreshId = 0;
            }
        }

        const displayActaualParamsOnScreen = (data) => {
            const outputs = document.querySelectorAll('.value-container .val');

            outputs[0].innerHTML = data.x.toFixed(4);
            outputs[1].innerHTML = data.y.toFixed(4);
            outputs[2].innerHTML = data.a.toFixed(4);
            outputs[3].innerHTML = data.b.toFixed(4);
            outputs[4].innerHTML = data.u.toFixed(4);
        }

        const programDatabase = [{
            name: "Henon",
            atractor: henon,
            startingPoints: {
                x: {
                    value: 0.1,
                    min: 0,
                    max: 1,
                    step: 0.1
                },
                y: {
                    value: 0,
                    min: 0,
                    max: 1,
                    step: 0.1
                },
                a: {
                    value: 1.4,
                    min: 1.3,
                    max: 6.2,
                    step: 0.1
                },
                b: {
                    value: 0.3,
                    min: 0.2,
                    max: 0.65,
                    step: 0.1
                },
                u: {
                    value: 0,
                    min: 0,
                    max: 0,
                    step: 0
                }
            }
        }, {
            name: "Lozi",
            atractor: lozi,
            startingPoints: {
                x: {
                    value: 0,
                    min: 0,
                    max: 1,
                    step: 0.1
                },
                y: {
                    value: 0,
                    min: 0,
                    max: 1,
                    step: 0.1
                },
                a: {
                    value: 1.7,
                    min: 1.2,
                    max: 1.75,
                    step: 0.05
                },
                b: {
                    value: 0.5,
                    min: 0.05,
                    max: 1,
                    step: 0.05
                },
                u: {
                    value: 0,
                    min: 0,
                    max: 0,
                    step: 0
                }
            }
        }, {
            name: "Duffing",
            atractor: duffing,
            startingPoints: {
                x: {
                    value: 0,
                    min: 0,
                    max: 1,
                    step: 0.1
                },
                y: {
                    value: 0.1,
                    min: 0,
                    max: 1,
                    step: 0.1
                },
                a: {
                    value: 2.75,
                    min: 2.65,
                    max: 2.77,
                    step: 0.01
                },
                b: {
                    value: 0.2,
                    min: 0.01,
                    max: 0.25,
                    step: 0.01
                },
                u: {
                    value: 0,
                    min: 0,
                    max: 0,
                    step: 0
                }
            }
        }, {
            name: "GingerBreadMan",
            atractor: gingerBreadMan,
            startingPoints: {
                x: {
                    value: -1.8,
                    min: -4,
                    max: 2.8,
                    step: 0.1
                },
                y: {
                    value: -1.8,
                    min: -4,
                    max: 2.8,
                    step: 0.05
                },
                a: {
                    value: 0,
                    min: 0,
                    max: 0,
                    step: 0
                },
                b: {
                    value: 0,
                    min: 0,
                    max: 0,
                    step: 0
                },
                u: {
                    value: 0,
                    min: 0,
                    max: 0,
                    step: 0
                }
            }
        }, {
            name: "Ikeda",
            atractor: ikeda,
            startingPoints: {
                x:{
                    value: 0.1,
                    min: 0.01,
                    max: 1,
                    step: 0.1
                },
                y:{
                    value: 0.1,
                    min: 0.01,
                    max: 1,
                    step: 0.1
                },
                a: {
                    value: 0,
                    min: 0,
                    max: 0,
                    step: 0
                },
                b: {
                    value: 0,
                    min: 0,
                    max: 0,
                    step: 0
                },
                u: {
                    value: 0.3,
                    min: 0.3,
                    max: 1.1,
                    step: 0.05
                }
            }
        }
        ]

        const data = {
            datasets: [{
                label: programDatabase[selectedAtractor].name,
                data: data_points,
                backgroundColor: 'rgb(255, 99, 132)'
            }],
        };

        const config = {
            type: 'scatter',
            data: data,
            options: {
                animations: false,
                scales: {
                    x: {
                        type: 'linear',
                        position: 'bottom'
                    }
                }
            }
        };

        const inputContainer = document.getElementById('input-container');

        inputContainer.innerHTML = slidersConfig.map((input, index) => `<div class="single-section">${labelTemplate(input, programDatabase[selectedAtractor].startingPoints[slidersConfig[index].variable])}</div>`).join('<br\>');
        const labels = inputContainer.querySelectorAll('.single-section label');
        
        
        const t_points = [];
        t_points[0] = 0.4 - 6 / (1 + data_points[0].x * data_points[0].x + data_points[0].y * data_points[0].y)

        const updateInputInfo = (clickedNodeDOM) => {
            //console.log(document.querySelector('h3').innerHTML = 'x = ' + node.valueAsNumber);
            const { variable, type } = clickedNodeDOM.dataset;

            console.log(clickedNodeDOM.dataset)

            if (type === 'step') {
                inputContainer.querySelector(
                    `input[data-type="range"][data-variable="${variable}"]`
                ).step = clickedNodeDOM.valueAsNumber;
            } else if (type === 'range') {
                currentSlidersParams[variable] = clickedNodeDOM.valueAsNumber;
                inputContainer.querySelector(
                    `input[data-type="val"][data-variable="${variable}"]`
                ).value = clickedNodeDOM.valueAsNumber;
            } else if (type === 'max') {
                inputContainer.querySelector(
                    `input[data-type="range"][data-variable="${variable}"]`
                ).max = clickedNodeDOM.valueAsNumber;
            } else if (type === 'min') {
                inputContainer.querySelector(
                    `input[data-type="range"][data-variable="${variable}"]`
                ).min = clickedNodeDOM.valueAsNumber;
            } else if (type === 'val') {
                inputContainer.querySelector(
                    `input[data-type="range"][data-variable="${variable}"]`
                ).min = clickedNodeDOM.valueAsNumber;
                currentSlidersParams[variable] = clickedNodeDOM.valueAsNumber;
            }

            if (variable == 'a') {
                a = clickedNodeDOM.valueAsNumber;
            } else if (variable == 'b') {
                b = clickedNodeDOM.valueAsNumber;
            } else if (variable == 'x') {
                data_points[0].x = clickedNodeDOM.valueAsNumber;
            } else if (variable == 'y') {
                data_points[0].y = clickedNodeDOM.valueAsNumber;
            } else if (variable == 'u') {
                u = clickedNodeDOM.valueAsNumber;
            }

            displayActaualParamsOnScreen(
                {
                    x: data_points[0].x,
                    y: data_points[0].y,
                    a,
                    b,
                    u
                }
            )

            console.log(currentSlidersParams);
            programDatabase[selectedAtractor].atractor(1, 5000);
            myChart.update();

        }

        henon(1, 5000);

        let myChart = new Chart(
            document.getElementById('myChart'),
            config
        );



        const intervalCall = () => {

            data_points[0].x = data_points[0].x - - jumpRange[0];
            data_points[0].y = data_points[0].y - - jumpRange[1];
            a = a - - jumpRange[2];
            b = b - - jumpRange[3];
            u = u - -jumpRange[4];

            displayActaualParamsOnScreen(
                {
                    x: data_points[0].x,
                    y: data_points[0].y,
                    a,
                    b,
                    u
                }
            )

           
            console.log({
                x: data_points[0].x,
                y: data_points[0].y,
                a,
                b,
                u
            }
               
           )
            
            // gingerBreadMan(1, 5000);
            programDatabase[selectedAtractor].atractor(1, 5000);

            myChart.update();
            console.log("interval callback")
        }

        const intervalCalblack = callback => {
            intervalRefreshId = setInterval(() => {
                callback()
            }, 50);
        }

    </script>


</body>

</html>